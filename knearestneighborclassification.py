# -*- coding: utf-8 -*-
"""KNearestNeighborClassification.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1BuOBdpio8i5E3dxzqnXSG-13Fd3D7CJF
"""

import pandas as pd
from google.colab import files
import io

uploaded = files.upload()

data = io.BytesIO(uploaded["traindata.csv"])
df = pd.read_csv(data, sep = None, engine = 'python')
df

df.describe()

df.info()

"""#Data Preprocessing

"""

#Split data untuk memisahkan features data dan target data
#data fitur
features = df[['x1', 'x2', 'x3']]
#data target
target = df["y"]

features.head()

"""#Folding
memisahkan dataframe menjadi beberapa bagian untuk melihat karakteristik data
"""

#mengambil quarter pertama untuk testing dan 3 quarter sisanya untuk training
fold_first_quarter = (df.iloc[0:74].reset_index(drop=True),              df.iloc[74:296].reset_index(drop=True))

#mengambil 50 persen data dengan menyilang masing-masing untuk training dan testing
fold_first_half = (pd.concat([df.iloc[0:74],df.iloc[148:222]]).reset_index(drop=True), pd.concat([df.iloc[74:148],df.iloc[222:296]]).reset_index(drop=True))
fold_second_half = (pd.concat([df.iloc[74:148],df.iloc[148:222]]).reset_index(drop=True), pd.concat([df.iloc[0:74],df.iloc[222:296]]).reset_index(drop=True))

#mengambil quarter akhir untuk testing dan quarter awal hingga quarter ke-tiga untuk training
fold_last_quarter = (df.iloc[0:222].reset_index(drop=True),           df.iloc[222:296].reset_index(drop=True))

fold_first_quarter

features.iloc[0] - features.iloc[1]

"""#Function Distance
2 rumus yang dapat dipakai untuk menghitung jarak
"""

def euclidean_distance(x, y):
    dist = 0
    for i in range(len(y)):
        dist += (x[i] - y[i])**2

    return dist ** (1/2)

def manhattan_distance(x, y):
    return (x-y).abs().sum()

print(manhattan_distance(features.iloc[0], features.iloc[1]))
print(euclidean_distance(features.iloc[0], features.iloc[1]))

"""#Normalisasi
###mengubah jarak data dari 0-1 agar jarak tidak terlalu timpang

"""

features = (features - features.min()) / (features.max()-features.min())

features.describe()

def predict(x,k,X,y):
  distance = []
  for _, row in X.iterrows():
    distance.append(manhattan_distance(x,row))

  data = X.copy()
  data['distance'] = distance
  data['clas'] = y
  data.sort_values(by="distance").reset_index(drop=True)

  y_pred = data.iloc[:k].clas.mode()

  return y_pred[0]

predict(features.iloc[6],1, features, target)

def akurasi(y_pred,y_true):
    n = len(y_pred)
    benar = 0
    for i in range(n):
       if y_pred[i] == y_true[i]:
        benar += 1
    return benar /n * 100

akurasi(target, target)

accurate = []

for k in range(1,100):
    for fold in [fold_first_quarter, fold_first_half, fold_second_half, fold_last_quarter]:
        train, test = fold
        X_train, y_train = train.drop('y', axis=1), train.y
        X_test, y_test = test.drop('y', axis=1), test.y

        y_preds = []
        for _, x in X_test.iterrows():
            y_preds.append(predict(x, k, X_train, y_train))

        accurate.append(akurasi(y_preds, y_test))

    print(f"Accuracy for k={k}: {sum(accurate) / len(accurate):.2f}%")