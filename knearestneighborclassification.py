# -*- coding: utf-8 -*-
"""KNearestNeighborClassification.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1BuOBdpio8i5E3dxzqnXSG-13Fd3D7CJF
"""

import pandas as pd
from google.colab import files
import io

uploaded = files.upload()

data = io.BytesIO(uploaded["traindata.csv"])
df = pd.read_csv(data, sep = None, engine = 'python')
df

df.describe()

df.info()

"""#Data Preprocessing

"""

#Split data untuk memisahkan features data dan target data
#data fitur
features = df[['x1', 'x2', 'x3']]
#data target
target = df["y"]

features.head()

"""#Normalisasi
###mengubah jarak data dari 0-1 agar jarak tidak terlalu timpang

"""

df = (df - df.min()) / (df.max()-df.min())

features.describe()

features.iloc[0] - features.iloc[1]

"""#Function Distance
2 rumus yang dapat dipakai untuk menghitung jarak
"""

def euclidean_distance(x, y):
    dist = 0
    for xi, yi in zip(x, y):
        dist += (xi - yi)**2

    return dist ** 0.5

    return dist ** (1/2)

import numpy as np

def manhattan_distance(x, y):
    return np.abs(np.array(x) - np.array(y)).sum()

print((features.iloc[0], features.iloc[1]))
print(euclidean_distance(features.iloc[0], features.iloc[1]))

def predict(x,k,X,y):
  distance = []
  for _, row in X.iterrows():
    distance.append(manhattan_distance(x,row))

  data = X.copy()
  data['distance'] = distance
  data['clas'] = y
  data.sort_values(by="distance").reset_index(drop=True)

  y_pred = data.iloc[:k].clas.mode().values

  return y_pred[0]

import numpy as np

def akurasi(y_pred, y_true):
    return np.mean(y_pred == y_true) * 100

"""#Folding
memisahkan dataframe menjadi beberapa bagian untuk melihat karakteristik data
"""

# Menentukan ukuran setiap bagian
size = len(df)
size_per_fold = size // 3

# Mengambil bagian pertama untuk testing dan dua bagian sisanya untuk training
fold_first = (df.iloc[:size_per_fold].reset_index(drop=True), df.iloc[size_per_fold:].reset_index(drop=True))

# Mengambil 50 persen data dengan menyilang masing-masing untuk training dan testing
fold_second = (pd.concat([df.iloc[:size_per_fold], df.iloc[2*size_per_fold:]]).reset_index(drop=True),
               pd.concat([df.iloc[size_per_fold:2*size_per_fold]]).reset_index(drop=True))

# Mengambil quarter akhir untuk testing dan dua quarter awal untuk training
fold_third = (df.iloc[size_per_fold:].reset_index(drop=True), df.iloc[:2*size_per_fold].reset_index(drop=True))

accurate = []

for k in range(1,22,2):
    for fold in [fold_first, fold_second, fold_third]:
        train, test = fold
        X_train, y_train = train.drop(['y', 'id'], axis=1), train.y
        X_test, y_test = test.drop(['y', 'id'], axis=1), test.y

        y_preds = []
        for _, x in X_test.iterrows():
            y_preds.append(predict(x, k, X_train, y_train))

        accurate.append(akurasi(y_preds, y_test))

    print(f"Accuracy for k={k}: {(max(accurate)):.2f}%")